
BOARD STATE
  Hybrid approach: Piece list for move generation with separate board square representation for lookups.  
GAME TREE
  Position object used as node in search tree
  Evaluation score stored in node
  edges to other nodes generated based on move list.
SEARCHING / TRAVERSAL ----
  Iterative Deepening
    =>  MTD(f) for scope narrowing
        =>  Alpha-Beta Pruning with memoization
            =>  Transposition hash table for memoization
EVALUATION ----
  Weighted pattern matching

Current Issues ----

  AI does not always select obvious best moves - does not always capture expensive units except via pawns.

Move Generation benchmarking (4-ply maximal tree, 197742 nodes)
  Using Location object - baseline: 46.596299 seconds
                          after refcatoring 12/30/13: 35.324076 seconds
                          after refactoring 1/5/14: 24.660283 seconds
                          after adding king safety 1/6/14: 25.213673 seconds
                          after switching to legal move generation: 33.068109 seconds

To Do ----

  Add separate PSTs for early- and late-game.

  Add Killer Heuristic to move ordering.
  Allow incremental calculation of hash values based on previous move of the Transposition Table.


  Move ordering by Principal Variation
  -when best_node is available from a TT entry, that means it's a PV node.  Explore PV nodes first(prior to standard move-gen)
  -set a pv_node flag in TT entries (or only entering a value for best_node if PV node)



  Explore adding search extensions to "interesting" branches:
    -checks
    -moves with MVV-LVA ratio greater than 2

  If capture or pawn move, reset halfmove_clock.  If any other move, increment halfmove_clock by 1.















