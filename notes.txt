
Move Generation benchmarking (4-ply maximal tree, 197742 nodes)
  baseline: 46.596299 seconds
  12/30/13: 35.324076 seconds
  1/5/14: 24.660283 seconds
  king safety 1/6/14: 25.213673 seconds
  legal copy/make: 33.068109 seconds
  incremental update: 9.475452 seconds
  iterative move gen and king saftey: 7.3749 seconds (26750 NPS)
  2/10/14 pseudolegal with king-loss checking: 3.419017 seconds (57835 NPS)

Search benchmarking (Win at Chess test suite):

  4/9/14 Baseline, ruby_only:

    Total AI score: 94/300 (31.333333333333336%)
    0.70220744 seconds/search at depth 4
    N: 1329152; E: 1261613; B: 2.975097929974432; Efficiency: 10.531866200990102

    Total AI score: 114/300 (38.0%)
    13.538827173333335 seconds/search at depth 6
    N: 25666314; E: 23056520; B: 3.597718489628773; Efficiency: 10.562249411548871


  5/4/14 After debugging attack.c

    Total AI score: 99/300 (33.0%)
    0.15935090666666668 seconds/search at depth 4
    N: 1913014; E: 1783802; B: 3.195094607130799; Efficiency: 10.328332665439932

    Total AI score: 122/300 (40.666666666666664%)
    4.0505759433333335 seconds/search at depth 6
    N: 41090377; E: 36098846; B: 3.736847072831139; Efficiency: 10.882614641186391


Current Issues ----

To Do ----


  Without piece list, updating tropism score will require looping over opposing bitboards to sum tropism
  bonuses.  Migrate tropism module and Evaluation::king_tropism to C.

  Replace attack.rb with bitboard-based 'can_attack(square)'' and 'is_attacked_by(square)' methods in C.
  
  Create 'attacks_to(square)' method in attack.c to find all attacking squares (incl. hidden attackers). Write an iterative SEE(sboard, sq) implementation in C that uses this function to get the SEE score for an attack.

  Create separate move generators for checks and check evasions. This will require a new attack.c module.

  Refactor utilities

  Create readme









Possible Enhancements to Add ----

  
  -Create a threat map showing where enemy king can be attacked from. Incrementally update map on make/unmake.
    Use to create a 'gives check' move generator. 
    Use to efficiently generate moves that give check while in q-search (up to some maximum number of checks between 4-7).
    Attack map could be used to substantially speed up board.evades_check? method.

  -Extend search on 'winning' promotions

  -At root, TT entries could be used for more accurate move ordering. Entry value would be used if available, 
   otherwise q-search could be used to establish an initial entry.  This would reduce branching factor and might improve strength,
   revealing beneficial lines that might otherwise have been cut off.






